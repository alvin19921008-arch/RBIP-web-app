# Step-Wise Workflow Data Architecture

This project uses a step-wise allocation workflow where each step builds upon the previous step's results. Proper data passing between steps is critical to prevent bugs where information is lost or ignored.

## Core Principles

### 1. staffOverrides is the Single Source of Truth

All user edits (leave type, FTE, team reassignment) are stored in `staffOverrides`. This state accumulates across all steps and is used by all sync and algorithm functions.

### 2. Data Continuity Across Steps

Each step must:
1. **Receive** all relevant data from previous steps (not just a subset)
2. **Accumulate** changes made during its execution
3. **Pass forward** the complete state to subsequent steps

### 3. Centralized Allocation Sync

The `useAllocationSync` hook (`lib/hooks/useAllocationSync.ts`) handles all allocation syncing centrally. Never add scattered `useEffect` hooks for allocation sync - use the hook instead.

## The Step-Wise Workflow

```
Step 1: Leave & FTE
    ↓ staffOverrides (leave types, FTE remaining, team changes)
Step 2: Therapist & Non-Floating PCA
    ↓ staffOverrides + step2Result (non-floating allocations, teamPCAAssigned)
Step 3: Floating PCA (Interactive Wizard: 3.0 → 3.1 → 3.2 → 3.3 → 3.4)
    ↓ staffOverrides + Step 2 allocations + pendingPCA-FTE/team
    ↓ Step 3.1: Adjust pending FTE & team order
    ↓ Step 3.2: Preferred slot assignments
    ↓ Step 3.3: Adjacent slot assignments
    ↓ Step 3.4: Final floating PCA algorithm
Step 4: Bed Relieving
    ↓ staffOverrides + all allocations + scheduleCalculations.ptPerTeam
```

**Buffer Staff Integration:**
- Buffer therapists: Assignable in Step 1 & 2 only
- Buffer floating PCA: Assignable in Step 3 onwards
- Buffer FTE (`buffer_fte`) used instead of default 1.0 FTE
- Independent dragging instances per team assignment

## Allocation Sync Architecture

### Two Sync Triggers

1. **On staffOverrides change** (within a step): Real-time UI sync
2. **On step transition** (currentStep changes): Full sync to populate "before algo" state

### Step-Specific Sync Behavior

| Step | PCA Types Handled | Sync Behavior |
|------|-------------------|---------------|
| Step 1 | None | Sync therapist allocations only; **recalculate schedule calculations immediately on staffOverrides change** |
| Step 2 | Non-floating, Substitution, Special Program | Sync therapist; PCA algo runs on button click |
| Step 3 | Floating (tie-breaker) | Sync therapist; preserve Step 2 PCA allocations |
| Step 4 | None | Sync therapist; bed algo uses PT/team from calculations |

**Step 1 Critical Rules:**
- **Schedule calculations must run even without allocations**: `recalculateScheduleCalculations()` builds therapist allocations from raw staff data when no allocations exist
- **Immediate recalculation**: When `staffOverrides` changes in Step 1, PT/team, avg PCA/team, and bed/team must update immediately
- **Special program FTE subtraction**: Do NOT subtract special program FTE in Step 1 (only in Step 2+). Floating PCA battery bars should show full FTE in Step 1
- **Stable avg PCA/team**: Use `totalPCAOnDuty` (from staff DB + staffOverrides) consistently, never `totalPCAFromAllocations`

### What Each Algo Reads

| Step | Algo | Data Sources |
|------|------|--------------|
| Step 2 | `generateAllocationsWithOverrides()` | `staffOverrides`: team, fteRemaining, leaveType, availableSlots; buffer staff with `buffer_fte` |
| Step 3 | `allocatePCA(phase='floating')` | 1. `existingAllocations` from Step 2; 2. `staffOverrides`: remaining FTE; 3. `pendingPCA-FTE/team` (adjusted from 3.1); 4. `teamOrder` (from 3.1); 5. Buffer floating PCA with `buffer_fte` |
| Step 4 | `allocateBeds()` | `scheduleCalculations.ptPerTeam` (derived from therapist allocations) |

### pendingPCA-FTE/team Calculation for Step 3

```
pendingPCA-FTE/team = avgPCAPerTeam - (non-floating PCA FTE already allocated to team)
```

**Important distinctions:**
- **Non-floating PCA** allocations from Step 2 → **REDUCE** pendingPCA-FTE/team
- **Floating PCA substituting non-floating** → **REDUCE** pendingPCA-FTE/team
- **Special program PCA** allocations → do **NOT** reduce pendingPCA-FTE/team

**Step 3.1 Adjustment:**
- Users can adjust pending FTE values per team (with upper limit constraint)
- Adjusted values become targets for Steps 3.2, 3.3, and 3.4
- **Critical**: Actual allocation in Step 3.4 is still limited by available floating PCA pool capacity
- Over-adjustment (exceeding available capacity) will result in partial fulfillment by algorithm

### Step Transition Data Flow

| Transition | What Carries Forward | What Gets Fed to Next Algo |
|------------|---------------------|---------------------------|
| Step 1 → Step 2 | `staffOverrides` | Therapist algo uses latest `staffOverrides`; PCA algo uses therapist result |
| Step 2 → Step 3 | `staffOverrides` + Step 2 PCA allocations | Floating algo receives Step 2 allocations as `existingAllocations` |
| Step 3 → Step 4 | `staffOverrides` + all PCA allocations | Bed algo uses `scheduleCalculations.ptPerTeam` |

**Critical Rule:** At each step transition, the sync hook:
1. Reads the **latest** `staffOverrides` (accumulated from all previous steps)
2. Rebuilds `therapistAllocations` to reflect any team/FTE changes
3. Preserves existing PCA allocations (only modified by their respective algo)
4. Updates `scheduleCalculations` so next step has accurate PT/team and avgPCA/team

**Optimization:** When transitioning from Step 2+ to Step 3+ with existing therapist allocations:
- Skips full therapist regeneration to preserve Step 2's SPT allocations
- Only updates FTE/leave values from `staffOverrides` on existing allocations
- This prevents unnecessary regeneration when no `staffOverrides` changes occurred
- If `staffOverrides` changes, TRIGGER 1 will regenerate anyway (correct behavior)

## Using the useAllocationSync Hook

```typescript
import { useAllocationSync } from '@/lib/hooks/useAllocationSync'

// In your component:
useAllocationSync({
  staffOverrides,
  currentStep,
  staff,
  therapistAllocations,
  pcaAllocations,
  specialPrograms,
  sptAllocations,
  selectedDate,
  setTherapistAllocations,
  recalculateScheduleCalculations,
})
```

The hook automatically:
- Syncs therapist allocations when `staffOverrides` changes (TRIGGER 1)
- Syncs on step transitions (TRIGGER 2)
- Recalculates schedule calculations after each sync
- Preserves existing SPT allocations when `includeSPTAllocation: false` (prevents SPT loss on sync)

**SPT Preservation Logic:**
- When `syncTherapistAllocations()` runs with `includeSPTAllocation: false`:
  1. Regenerates all therapist allocations (APPT, RPT, SPT) based on `staffOverrides` or default teams
  2. Collects all existing SPT allocations from ALL teams (not just current team)
  3. Checks if each SPT exists in ANY team in the new result
  4. If not found, preserves it but updates team/FTE from `staffOverrides`
  5. Prevents duplicates when SPTs are moved between teams

## Critical Data Structures

### `staffOverrides`

**Purpose:** Tracks user edits to staff properties that persist across all steps.

**Structure:**
```typescript
Record<string, {
  leaveType: LeaveType | null
  fteRemaining: number
  team?: Team  // For therapist reassignment
  fteSubtraction?: number
  availableSlots?: number[]
  invalidSlot?: number
  leaveComebackTime?: string
  isLeave?: boolean
  slotOverrides?: {  // For manual PCA slot transfers
    slot1?: Team | null
    slot2?: Team | null
    slot3?: Team | null
    slot4?: Team | null
  }
}>
```

**Rule:** Any function that processes staff data MUST check `staffOverrides` first before using default values from the database.

**Slot Overrides:** Manual slot transfers (drag-and-drop) for floating PCA staff cards are stored in `slotOverrides`. These override the slot assignments from algorithm-generated allocations and persist through step transitions.

**Buffer Staff:**
- Buffer staff have `status: 'buffer'` and `buffer_fte` field in database
- Buffer therapists (SPT, APPT, RPT): Assignable in Step 1 & 2 only
- Buffer floating PCA: Assignable in Step 3 onwards
- Use `buffer_fte` instead of default 1.0 FTE for calculations
- Independent dragging instances per team assignment (similar to floating PCA)

### `step2Result`

**Purpose:** Persists Step 2 outputs for Step 3 to use.

**Structure:**
```typescript
{
  pcaData: PCAData[]
  teamPCAAssigned: Record<Team, number>
  nonFloatingAllocations: PCAAllocation[]
  rawAveragePCAPerTeam: Record<Team, number>
}
```

### Allocation State: `therapistAllocations` and `pcaAllocations`

**Purpose:** Current allocation state that reflects all steps completed so far.

**Rule:** When recalculating data for a subsequent step, always read from the current allocation state, not from stale snapshots.

### Schedule Calculations: `calculations`

**Purpose:** Calculated metrics per team, including `average_pca_per_team` (target requirement).

**Critical Stability Rule:** 
- `average_pca_per_team` must be **STABLE** regardless of allocation state
- Use `totalPCAOnDuty` (from staff database) for requirement calculation, NOT `totalPCAFromAllocations`
- Formula: `averagePCAPerTeam = (ptPerTeam * totalPCAOnDuty) / totalPTOnDutyAllTeams`
- `totalPCAOnDuty`: Sum of FTE from all on-duty PCAs in `staff` DB + `staffOverrides` (stable)
- `totalPCAFromAllocations`: Sum of FTE from currently allocated PCAs (unstable, for reference only)

**Auto-Recalculation:**
- `recalculateScheduleCalculations()` is automatically called when `therapistAllocations` or `pcaAllocations` change
- **Step 1 behavior**: Runs even without allocations, building therapist allocations from staff data for accurate calculations
- Ensures displayed `avg PCA/team` updates immediately after Step 2 algo adds SPTs to teams
- Uses `staffOverrides` for current FTE values (not stale `alloc.fte_therapist`)
- **Critical**: In Step 1, must recalculate immediately when `staffOverrides` changes to update PT/team, avg PCA/team, and bed/team

## Step 1 Specific Rules

### Rule 0: Step 1 Calculation Behavior

**Problem (FIXED):** Schedule calculations (PT/team, avg PCA/team, bed/team) were not updating in Step 1 when staff leave/FTE was edited.

**Solution:**
- `recalculateScheduleCalculations()` must run in Step 1 even without existing allocations
- When no allocations exist, build minimal therapist allocation objects from staff data for calculation purposes
- Use `staffOverrides` for current FTE values (not database defaults)
- Recalculate immediately when `staffOverrides` changes in Step 1

**Special Program FTE Subtraction:**
- **Step 1**: Do NOT subtract special program FTE from floating PCA's `getTrueFTERemaining`
- **Step 2+**: Subtract special program FTE (special programs are assigned in Step 2)
- This ensures floating PCA battery bars show correct FTE in Step 1 (not prematurely reduced)

**Avg PCA/Team Stability:**
- Always use `totalPCAOnDuty` (sum from staff DB + staffOverrides) for requirement calculation
- Never use `totalPCAFromAllocations` (unstable, changes with allocation state)
- Formula: `averagePCAPerTeam = (ptPerTeam * totalPCAOnDuty) / totalPTOnDutyAllTeams`
- This ensures `avg PCA/team` remains stable across step transitions

## Data Passing Rules

### Rule 1: Include ALL Allocations with Assigned Slots

**Bug Pattern (FIXED):** `recalculateFromCurrentState()` only returned non-floating allocations, causing Step 3 to treat floating PCAs used for substitution as fully available.

**Correct Pattern:**
```typescript
// WRONG: Only non-floating allocations
if (staffMember && !staffMember.floating) {
  existingAllocations.push(alloc)
}

// CORRECT: All allocations with slots assigned
const hasSlots = alloc.slot1 !== null || alloc.slot2 !== null || 
                alloc.slot3 !== null || alloc.slot4 !== null
if (!staffMember.floating || hasSlots) {
  existingAllocations.push(alloc)
}
```

### Rule 2: Recalculate from Current State Before Each Step

When starting a new step, recalculate derived data from the current allocation state to pick up any edits made after the previous step completed.

```typescript
// Before Step 3
const { teamPCAAssigned, existingAllocations } = recalculateFromCurrentState()
const pcaData = buildPCADataFromCurrentState()
```

### Rule 3: Algorithms Must Respect Existing Allocations

When an algorithm receives `existingAllocations`, it MUST:
1. Start with those allocations as the base
2. Check if a staff member already has an allocation before treating them as "available"
3. Respect slot assignments already made

```typescript
// In allocatePCA for floating phase
const allocations: PCAAllocation[] = phase === 'floating' && context.existingAllocations 
  ? [...context.existingAllocations]  // Start with existing
  : []

// When checking if a floating PCA is available
const remainingFloatingPCA = floatingPCA.filter(pca => {
  const allocation = allocations.find(a => a.staff_id === pca.id)
  if (!allocation) return true  // No allocation yet
  
  // Check if all slots are assigned
  const allSlotsAssigned = allocation.slot1 !== null && 
                          allocation.slot2 !== null && 
                          allocation.slot3 !== null && 
                          allocation.slot4 !== null
  if (allSlotsAssigned) return false  // Fully used
  
  return allocation.fte_remaining > 0
})
```

### Rule 4: Substitution Allocations Count as Used

When a floating PCA substitutes for a non-floating PCA (whole-day or partial), those slots are USED:
- The floating PCA's slots are assigned to the non-floating's team
- The floating PCA's `fte_remaining` decreases
- This allocation MUST be passed to subsequent steps

### Rule 5: Never Filter Out Data Silently

If a function filters allocations or staff, document WHY and ensure the filtering doesn't break downstream steps.

**Bad Pattern:**
```typescript
// Silently filtering - downstream steps don't know what's missing
const filteredData = allocations.filter(a => someCondition)
```

**Good Pattern:**
```typescript
// Explicit about what's included and why
const existingAllocations: PCAAllocation[] = []
allocs.forEach(alloc => {
  const staffMember = staff.find(s => s.id === alloc.staff_id)
  // Include non-floating allocations
  // Include floating allocations with slots assigned (substitutions)
  const hasSlots = alloc.slot1 !== null || alloc.slot2 !== null || 
                  alloc.slot3 !== null || alloc.slot4 !== null
  if (!staffMember?.floating || hasSlots) {
    existingAllocations.push(alloc)
  }
})
```

## Debugging Data Flow Issues

When debugging step-wise workflow bugs:

1. **Log what each step receives:** Check `existingAllocations`, `teamPCAAssigned`, `pcaPool`
2. **Log what each step produces:** Check the allocations array after processing
3. **Compare:** Does the next step receive everything the previous step produced?
4. **Check filters:** Are any filter functions removing data that should be passed forward?

## Function Reference

| Function | Purpose | Data In | Data Out |
|----------|---------|---------|----------|
| `useAllocationSync()` | Centralized allocation sync hook | `staffOverrides`, `currentStep`, allocations | Auto-syncs therapist allocations |
| `detectChanges()` | Detect what changed in staffOverrides | current/previous `staffOverrides` | `{ hasTeamChange, hasFTEChange, ... }` |
| `recalculateFromCurrentState()` | Extract current state for next step | `pcaAllocations`, `staffOverrides`, `staff` | `{ teamPCAAssigned, existingAllocations }` |
| `buildPCADataFromCurrentState()` | Build PCA pool with current FTE | `staff`, `staffOverrides` | `PCAData[]` |
| `allocatePCA()` with `phase='floating'` | Allocate floating PCAs | `existingAllocations`, `pcaPool`, `teamPCAAssigned` | `PCAAllocation[]` |

## Manual Overrides: Slot Transfers

### Floating PCA Slot Transfer
- **Functionality**: Drag-and-drop interface for transferring PCA slots between teams
- **Single-slot PCA**: Direct drag transfers 0.25 FTE to target team
- **Multi-slot PCA**: 
  - Popover appears when card is dragged out of original team
  - User selects which slots to transfer
  - Selected slots are dragged as a group
- **Storage**: Transfers are stored in `staffOverrides[staffId].slotOverrides` with per-slot team assignments
- **Effects**: 
  - Updates `assigned_PCA-FTE/team` for source and target teams
  - Updates `pendingPCA-FTE/team` (increases for source, decreases for target)
  - Updates `pcaAllocations` display immediately
- **Restrictions**: 
  - Special program slots cannot be dragged or accept drops
  - Only regular (non-special-program) slots can be transferred
  - Allocated slots split into separate display cards when a PCA has both special program and regular slots in the same team

### Step-Based Validation

The workflow enforces step-specific restrictions on certain actions:

| Action | Allowed Steps | Validation |
|--------|---------------|------------|
| **Floating PCA Slot Transfer** | Step 3 ('floating-pca') onwards | Warning popover if attempted before Step 3 |
| **Therapist Transfer** | Step 1 ('leave-fte'), Step 2 ('therapist-pca') | Warning popover if attempted after Step 2 |
| **Leave Arrangement Editing** | Step 1 ('leave-fte') only | Warning popover if attempted after Step 1 |

**Warning Popover Behavior:**
- Appears near the staff card being manipulated
- Auto-dismisses after 5 seconds
- Includes X button for manual dismissal
- Only triggers when card is dragged OUT of its original team column (for transfers)

## Checklist for New Step-Wise Features

- [ ] Does the new step receive all allocations from previous steps?
- [ ] Does it respect existing slot assignments?
- [ ] Does it update `staffOverrides` for user edits (including `slotOverrides`)?
- [ ] Does it pass complete data to subsequent steps?
- [ ] Are there any filters that might silently drop important data?
- [ ] Is `useAllocationSync` used for real-time sync (not scattered useEffects)?
- [ ] Does step transition correctly populate "before algo" state?
- [ ] Are step-based validations enforced for manual override actions?
- [ ] Are calculations using `totalPCAOnDuty` (stable) instead of `totalPCAFromAllocations` (unstable)?
- [ ] Are SPT allocations preserved correctly when `includeSPTAllocation: false`?
- [ ] Does the preserve logic check across ALL teams to prevent duplicates when SPTs are moved?
- [ ] Does `recalculateScheduleCalculations()` run in Step 1 even without allocations?
- [ ] Are schedule calculations (PT/team, avg PCA/team, bed/team) updated immediately when `staffOverrides` changes in Step 1?
- [ ] Is special program FTE subtraction skipped in Step 1 (only subtracts in Step 2+)?
- [ ] Are buffer staff handled correctly with `buffer_fte` instead of default 1.0 FTE?
- [ ] Are buffer therapist assignments restricted to Step 1 & 2 only?
- [ ] Are buffer floating PCA assignments restricted to Step 3 onwards?
- [ ] Does Step 3.1 adjustment respect upper limit constraints and available floating PCA capacity?
- [ ] Are Step 3.2/3.3 assignments properly counted toward total allocated FTE before Step 3.4 algorithm runs?